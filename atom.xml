<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xhy&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-20T12:17:27.391Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阅读之图解HTTP-认识简单的HTTP协议</title>
    <link href="http://yoursite.com/2020/06/14/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-%E8%AE%A4%E8%AF%86%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/"/>
    <id>http://yoursite.com/2020/06/14/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-%E8%AE%A4%E8%AF%86%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/</id>
    <published>2020-06-14T07:19:28.000Z</published>
    <updated>2020-06-20T12:17:27.391Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/06/14/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-%E8%AE%A4%E8%AF%86%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/banner.png" alt="在这里插入图片描述"></p><a id="more"></a>        <h1 id="HTTP">          <a href="#HTTP" class="heading-link"><i class="fas fa-link"></i></a>HTTP</h1>      <ul><li>HTTP协议用于客户端和服务端之间的通信</li><li>通过请求和响应进行通信，请求由客户端发出，响应由服务器端回复</li><li>无状态协议，不保存状态信息，为了实现保存状态信息，引入了cookie<ul><li>1.客户端发起第一次请求</li><li>2.服务器端，生成Cookie信息，通过set-Cookie首部字段信息，通知客户端保存Cookie</li><li>3.下一次客户端请求时，客户端会自动在请求报文上添加Cookie信息</li><li>4.服务器端收到，对比服务器上的内容，判定用户是谁</li></ul></li><li>持久连接：最初HTTP，每进行一次HTTP通信，就要断开一次TCP连接，HTTP/1.1 引入了持久连接keep-alive，如果任意一端没有明确提出断开连接，则保存TCP连接</li><li>管线化：以前，发送请求需等待并收到响应之后，才能发送下一个请求，引入管线化技术之后，可以同时并行发送多个请求，而不需要等待响应了</li></ul>        <h1 id="HTTP报文">          <a href="#HTTP报文" class="heading-link"><i class="fas fa-link"></i></a>HTTP报文</h1>      <p><img src="https://img-blog.csdnimg.cn/20200614092402491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducw==,size_16,color_FFFFFF,t_70" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducwpx;" alt="在这里插入图片描述"><br>HTTP报文大致可分为报文首部和报文主体部分<br>报文主体 = 实体主体<br>实体 = 实体首部 + 实体主体<br>⚠️报文主体不是必须的，报文主体传送的内容，是应该被发送的数据<br>例如：  </p><ul><li>1.用户只是想获取资源，使用GET方法，请求报文的报文主体就没有内容了  </li><li>2.用户向服务器传送文件，使用PUT方法，在请求报文的报文主体包含传送内容  </li><li>3.服务器返回用户请求的资源，在响应报文的报文主体中包含请求资源  </li><li>4.服务器返回304状态码时，告诉用户使用未过期的缓存，响应报文的报文主体为空 </li></ul>        <h1 id="请求报文首部">          <a href="#请求报文首部" class="heading-link"><i class="fas fa-link"></i></a>请求报文首部</h1>      <p><img src="https://img-blog.csdnimg.cn/20200614095005202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducw==,size_16,color_FFFFFF,t_70#pic_center" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducwpx;" alt="在这里插入图片描述"><br>请求行 = 请求方法 + 请求UR I+ 协议版本号   GET /index.html  HTTP/1.1<br>请求访问某台HTTP服务器上的/index.html页面资源</p>        <h2 id="请求方法">          <a href="#请求方法" class="heading-link"><i class="fas fa-link"></i></a>请求方法</h2>      <ul><li>GET：获取资源</li><li>POST：传输请求报文主体，目的不在于获取响应的报文主体</li><li>PUT：传输文件，在请求报文主体中加入文件内容</li><li>HEAD：与GET方法一样，不过不返回报文主体内容</li><li>DELETE：删除文件</li><li>OPTIONS：询问支持的方法，查询指定资源支持的方法</li><li>TRACE：追踪路径</li><li>CONNECT：要求用隧道协议连接代理</li></ul>        <h1 id="响应报文首部">          <a href="#响应报文首部" class="heading-link"><i class="fas fa-link"></i></a>响应报文首部</h1>      <p><img src="https://img-blog.csdnimg.cn/20200614135431523.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducw==,size_16,color_FFFFFF,t_70#pic_center" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducwpx;" alt="在这里插入图片描述"><br>状态行 = 协议版本号 + 状态码数值 + 原因短语   HTTP/1.1 200 OK  </p>        <h2 id="状态码">          <a href="#状态码" class="heading-link"><i class="fas fa-link"></i></a>状态码</h2>      <p>状态码 = 状态码数值 + 原因短语  </p><ul><li>        <h3 id="状态码类别">          <a href="#状态码类别" class="heading-link"><i class="fas fa-link"></i></a>状态码类别</h3>      <ul><li>1XX：信息性状态码————–接收的请求正在被处理</li><li>2XX：成功状态码—————-请求正常处理完毕</li><li>3XX：重定向状态码————–需要进行附加操作以完成请求</li><li>4XX：客户端错误状态码———服务器无法处理请求</li><li>5XX：服务器端错误状态码——-服务器处理请求出错<br>⚠️只要遵循状态码列表的定义，即使改变RFC2616中定义的状态码，或服务器端自行创建状态码都没问题 </li></ul></li><li>        <h3 id="常见状态码">          <a href="#常见状态码" class="heading-link"><i class="fas fa-link"></i></a>常见状态码</h3>      <ul><li>200 OK—————————-表示服务器端正常处理了客户端发来的请求<br>不过，不同的请求方法，会得到不同的结果<br>使用GET方法时，对应的请求资源会作为响应返回；<br>使用HEAD方法时，对应资源则不会作为响应返回，只返回报文首部，服务器被动不返回报文主体</li><li>204 NO Content——————-请求处理成功，但没有资源返回<br>响应报文中不含报文主体，服务器主动不返回报文主体</li><li>206 Partial Content—————-客户端进行了范围请求<br>实际上服务器上成功的执行了GET请求，但是客户端要求，返回指定范围内的数据</li><li>301  Moved Permanently———–永久性重定向<br>客户端访问的资源，被服务器端永久的分配了新的URI（统一资源标识符），此时服务器端在响应报文中添加Location首部字段，客户端保存提示的URI，自动根据新的URI再次发松请求，得到数据</li><li>302 Found————————-临时性重定向<br>服务器端临时移动了资源，服务器带有新的URI响应，客户端不保存新的URI，自动根据新的URI发送请求，得到数据</li><li>303 See Other———————URI已经更新，明确提示客户端使用GET方法请求获取资源<br>与301，302对比，301，302 没有明确指定客户端下一次的请求方法，<br>但是，其实几乎所有的浏览器都会把POST改成GET，并删除请求报文中的报文主体部分</li><li>304 Not Modified————–资源已找到，但不符合客户端传来的条件<br>其实与重定向没有关系，表示，客户端直接使用了未过期的缓存</li><li>307 Temporary Redirect——临时重定向<br>与302 相同，但307不会改变请求方法</li><li>400 Bad Request————-请求中存在语法错误  </li><li>401 Unauthorized————-请求中的认证失败  </li><li>403 Forbidden—————-服务器端不允许访问该资源  </li><li>404 Not Found—————-服务器上没有该资源，或服务器端拒绝请求且不想说明理由  </li><li>500 Internal Server Error——-服务器端发生了内部故障  </li><li>503 Service Unavailable——–服务器暂时处于超负荷或正在进行停机维护状态  </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/06/14/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-%E8%AE%A4%E8%AF%86%E7%AE%80%E5%8D%95%E7%9A%84HTTP%E5%8D%8F%E8%AE%AE/banner.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/learning/HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读之图解HTTP-URI与URL</title>
    <link href="http://yoursite.com/2020/06/14/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-URI%E4%B8%8EURL/"/>
    <id>http://yoursite.com/2020/06/14/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-URI%E4%B8%8EURL/</id>
    <published>2020-06-14T00:23:41.000Z</published>
    <updated>2020-06-20T12:17:27.382Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/06/14/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-URI%E4%B8%8EURL/banner.png" alt></p><a id="more"></a>        <h1 id="URI：统一资源标识符">          <a href="#URI：统一资源标识符" class="heading-link"><i class="fas fa-link"></i></a>URI：统一资源标识符</h1>      <p>URI：Uniform Resource Identifier（用字符串标识某一互联网资源）</p><ul><li>Uniform：用统一的格式，处理不同类型的资源</li><li>Resource：资源文件，资源表示可标识的任何东西（文档，图像，服务）</li><li>Identifier：可标志的对象（标志符）</li><li>URI指的就是由某个协议方案表示的资源的定位标识符</li></ul>        <h1 id="URL：统一资源定位符">          <a href="#URL：统一资源定位符" class="heading-link"><i class="fas fa-link"></i></a>URL：统一资源定位符</h1>      <p>URL：表示的资源的地点（互联网所处位置）</p>        <h1 id="联系">          <a href="#联系" class="heading-link"><i class="fas fa-link"></i></a>联系</h1>      <p>URL是一种具体的URI，即URL不仅标识一个资源，而且还指明了这个资源的地址。<br>URL 是URI 的子集</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/06/14/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-URI%E4%B8%8EURL/banner.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/learning/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>阅读之图解HTTP-TCP/IP协议族</title>
    <link href="http://yoursite.com/2020/06/13/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/"/>
    <id>http://yoursite.com/2020/06/13/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/</id>
    <published>2020-06-13T13:06:30.000Z</published>
    <updated>2020-06-20T12:17:27.359Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/06/13/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/banner.png" alt="在这里插入图片描述"></p><a id="more"></a>        <h1 id="什么是协议？">          <a href="#什么是协议？" class="heading-link"><i class="fas fa-link"></i></a>什么是协议？</h1>      <p>计算机要在网络中进行通信，双方就必须基于相同的方法，例如如何探测到通信目标，由哪一边先发起通信，使用哪种语言进行通信，怎样结束通信等规则，都需要事先确定，这种规则就叫做协议</p>        <h1 id="TCP-IP协议族：">          <a href="#TCP-IP协议族：" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP协议族：</h1>      <ul><li>        <h2 id="协议族是什么？">          <a href="#协议族是什么？" class="heading-link"><i class="fas fa-link"></i></a>协议族是什么？</h2>      <p>  把互联网相关联的协议集合起来总称为协议族</p></li><li>        <h2 id="与OSI参考模型是什么关系？">          <a href="#与OSI参考模型是什么关系？" class="heading-link"><i class="fas fa-link"></i></a>与OSI参考模型是什么关系？</h2>      <p>  OSI参考模型是一个理论上的(理想)网络通信模型，而TCP/IP协议族则是实际运行的网络协议<br>  <img src="https://img-blog.csdnimg.cn/2020061317530089.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducw==,size_16,color_FFFFFF,t_70#pic_center" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducwpx;" alt="在这里插入图片描述"></p><pre><code>TCP/IP协议族中的每一层，都有不同的协议</code></pre></li><li>        <h2 id="TCP-IP怎样进行通信传输？">          <a href="#TCP-IP怎样进行通信传输？" class="heading-link"><i class="fas fa-link"></i></a>TCP/IP怎样进行通信传输？</h2>      <p>  <img src="https://img-blog.csdnimg.cn/20200613181546109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducw==,size_16,color_FFFFFF,t_70#pic_center" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducwpx;" alt="在这里插入图片描述"><br>  1.客户端在应用层发起http请求，向下传给传输层<br>  2.传输层的TCP协议对HTTP请求报文进行分割，并在报文上打上标记，传给网络层<br>  3.网络层，通过ARP寻找服务器端的MAC地址，根据路由选择进行中转<br>  4.服务器端在链路层接收到数据，向上传，传输到应用层<br>  ⚠️⚠️⚠️HTTP是是基于TCP的，所以首先会先建立tcp连接（三次握手），再建立HTTP连接</p></li><li>        <h2 id="各层协议简介">          <a href="#各层协议简介" class="heading-link"><i class="fas fa-link"></i></a>各层协议简介</h2>      <ul><li>FTP：文件传输协议，基于TCP  </li><li>DNS：域名系统服务，提供域名和IP地址的映射，ip地址不符合我们的记忆习惯  </li><li>HTTP：超文本传输协议  </li><li>TCP：面向连接的、可靠的、基于字节流的传输层通信协议  </li><li>UDP：面向无连接的，基于数据报的传输层协议  </li><li>IP：网际协议，IP地址指明了节点被分配到的地址  </li><li>ARP：地址解析协议，用于查询ip地址的MAC地址（全球唯一）  </li><li>RARP： 逆地址解析协议，用于把MAC地址转换成IP地址  </li><li>HTTP：超文本传输协议 </li></ul></li></ul>        <h1 id="TCP的三次握手策略">          <a href="#TCP的三次握手策略" class="heading-link"><i class="fas fa-link"></i></a>TCP的三次握手策略</h1>      <p>握手过程中使用了TCP的标志<br>1.SYN(发送标记位)<br>2.seq(序列号)<br>3.ACK(确认值，值为1即为确认已连接)<br>4.ack(确认编号，即对方主机传过来的seq+1)<br><img src="https://img-blog.csdnimg.cn/2020061320111951.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducw==,size_16,color_FFFFFF,t_70#pic_center" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducwpx;" alt="在这里插入图片描述"></p>        <h1 id="TCP的四次挥手">          <a href="#TCP的四次挥手" class="heading-link"><i class="fas fa-link"></i></a>TCP的四次挥手</h1>      <p>握手过程中使用了TCP的标志<br>1.FIN<br>2.seq(序号)<br>3.ACK(确认值，值为1即为确认已连接)<br>4.ack(确认编号，即对方主机传过来的seq+1)<br><img src="https://img-blog.csdnimg.cn/20200613204938501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducw==,size_16,color_FFFFFF,t_70#pic_center" style="width: image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,tepx;height: t_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hoeXh4aHducwpx;" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/06/13/%E9%98%85%E8%AF%BB%E4%B9%8B%E5%9B%BE%E8%A7%A3HTTP-TCP-IP%E5%8D%8F%E8%AE%AE%E6%97%8F/banner.png&quot; alt=&quot;在这里插入图片描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
      <category term="图解HTTP" scheme="http://yoursite.com/categories/learning/%E5%9B%BE%E8%A7%A3HTTP/"/>
    
    
  </entry>
  
  <entry>
    <title>学习之es6运算符...</title>
    <link href="http://yoursite.com/2020/05/31/%E5%AD%A6%E4%B9%A0%E4%B9%8Bes6%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>http://yoursite.com/2020/05/31/%E5%AD%A6%E4%B9%A0%E4%B9%8Bes6%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-05-31T09:58:05.000Z</published>
    <updated>2020-06-20T12:17:27.351Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/05/31/%E5%AD%A6%E4%B9%A0%E4%B9%8Bes6%E8%BF%90%E7%AE%97%E7%AC%A6/banner.png" alt></p><a id="more"></a>        <h1 id="1-扩展运算符-spread-———–应用">          <a href="#1-扩展运算符-spread-———–应用" class="heading-link"><i class="fas fa-link"></i></a>1.扩展运算符(spread)———–应用</h1>      <p>将一个数组转为用逗号分离的序列</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="string">'xxx'</span>,<span class="string">'hhh'</span>,<span class="string">'yyy'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span>,...a,<span class="string">'1'</span>)<span class="comment">// 1 xxx hhh yyy 1</span></span><br><span class="line"><span class="comment">// 即...a 为 'xxx','hhh','yyy'</span></span><br></pre></td></tr></table></div></figure><ul><li>        <h2 id="作为函数调用的参数">          <a href="#作为函数调用的参数" class="heading-link"><i class="fas fa-link"></i></a>作为函数调用的参数</h2>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line"><span class="built_in">console</span>.log(add(...numbers)) <span class="comment">// 42</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="替代函数的-apply-方法">          <a href="#替代函数的-apply-方法" class="heading-link"><i class="fas fa-link"></i></a>替代函数的 apply 方法</h2>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>, <span class="number">11</span>);<span class="comment">// max函数需要传入多个参数</span></span><br><span class="line"><span class="comment">//当参数在一个数组里面时，使用aplly方法，传入数组参数</span></span><br><span class="line"><span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>, <span class="number">11</span>])</span><br><span class="line"><span class="comment">// 有了...运算符，不用使用apply方法了</span></span><br><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="复制数组">          <a href="#复制数组" class="heading-link"><i class="fas fa-link"></i></a>复制数组</h2>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];<span class="comment">// 写法一，得到的是一个新的数组并不是复制了指针地址</span></span><br><span class="line"><span class="keyword">const</span> [...a3] = a1;<span class="comment">// 写法二,与写法一得到的结果一样，相当于...a3创建了一个新的数组，并把a1里的值给了a3新创建的数组</span></span><br><span class="line"><span class="built_in">console</span>.log(a1)<span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(a2)<span class="comment">// [ 1, 2 ]</span></span><br><span class="line"><span class="built_in">console</span>.log(a3)<span class="comment">// [ 1, 2 ]</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="合并数组">          <a href="#合并数组" class="heading-link"><i class="fas fa-link"></i></a>合并数组</h2>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">const</span> arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"><span class="keyword">const</span> arr4 = [...arr1, ...arr2, ...arr3]</span><br><span class="line"><span class="built_in">console</span>.log(arr4)<span class="comment">// [ 'a', 'b', 'c', 'd', 'e' ]</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="与解构赋值结合">          <a href="#与解构赋值结合" class="heading-link"><i class="fas fa-link"></i></a>与解构赋值结合</h2>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [first, ...rest] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">first <span class="comment">// 1</span></span><br><span class="line">rest  <span class="comment">// [2, 3, 4, 5]跟复制数组的第二种写法类似</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="字符串">          <a href="#字符串" class="heading-link"><i class="fas fa-link"></i></a>字符串</h2>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]<span class="comment">// [ "h", "e", "l", "l", "o" ]</span></span><br></pre></td></tr></table></div></figure></li></ul>        <h1 id="2-rest-参数-…变量名">          <a href="#2-rest-参数-…变量名" class="heading-link"><i class="fas fa-link"></i></a>2.rest 参数(…变量名)</h1>      <p>用于获取函数的多余参数</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add1</span>(<span class="params">x,y,...values</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(values) <span class="comment">// [ 5, 10 ]</span></span><br><span class="line">  <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add1(<span class="number">2</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">10</span>))<span class="comment">// 6</span></span><br></pre></td></tr></table></div></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/05/31/%E5%AD%A6%E4%B9%A0%E4%B9%8Bes6%E8%BF%90%E7%AE%97%E7%AC%A6/banner.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>js循环对象方法</title>
    <link href="http://yoursite.com/2020/05/31/js%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/31/js%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-31T08:02:54.000Z</published>
    <updated>2020-06-20T12:09:24.454Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/05/31/js%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/banner.png" alt></p><a id="more"></a><p>先创建一个对象</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  name:<span class="string">'xhy'</span>,</span><br><span class="line">  age:<span class="number">18</span>,</span><br><span class="line">  eat: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'热爱美食'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>        <h1 id="for-in">          <a href="#for-in" class="heading-link"><i class="fas fa-link"></i></a>for in</h1>      循环遍历出key，根据key去数组中取出值<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key)<span class="comment">// name age eat</span></span><br><span class="line">  <span class="built_in">console</span>.log(obj[key])<span class="comment">// xhy 18 function</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li><li>        <h1 id="Object-keys-obj-与-Object-getOwnPropertyNames-obj">          <a href="#Object-keys-obj-与-Object-getOwnPropertyNames-obj" class="heading-link"><i class="fas fa-link"></i></a>Object.keys(obj) 与 Object.getOwnPropertyNames(obj)</h1>      <ul><li>1.Object.keys（obj）返回一个obj对象的key组成的数组，不包括不可枚举的属性</li><li>2.Object.getOwnPropertyNames（obj） 返回一个obj对象的key组成的数组，包括不可枚举的属性<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj))<span class="comment">// [ 'name', 'age', 'eat' ]</span></span><br><span class="line"><span class="comment">// 把age变成不可枚举的</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'age'</span> ,&#123;</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(obj))<span class="comment">// [ 'name', 'eat' ]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(obj))<span class="comment">// [ 'name', 'age', 'eat' ]</span></span><br></pre></td></tr></table></div></figure></li></ul></li><li>        <h1 id="Object-values（obj）">          <a href="#Object-values（obj）" class="heading-link"><i class="fas fa-link"></i></a>Object.values（obj）</h1>      返回一个obj对象的value组成的数组,不包括不可枚举的属性<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj))<span class="comment">// [ 'xhy', [Function: eat] ]</span></span><br><span class="line"><span class="comment">// 把eat变成不可枚举的</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'eat'</span> ,&#123;</span><br><span class="line">  enumerable: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.values(obj))<span class="comment">//[ 'xhy' ]</span></span><br></pre></td></tr></table></div></figure></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/05/31/js%E5%BE%AA%E7%8E%AF%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95/banner.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="summary" scheme="http://yoursite.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>js循环数组的方法</title>
    <link href="http://yoursite.com/2020/05/31/js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/31/js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-31T04:44:41.000Z</published>
    <updated>2020-06-20T12:09:24.471Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/05/31/js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/banner.png" alt></p><a id="more"></a><p>先声明一个数组</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'你'</span>,<span class="string">'我'</span>,<span class="string">'他'</span>,<span class="string">'你'</span>]</span><br></pre></td></tr></table></div></figure><ul><li>        <h2 id="for循环">          <a href="#for循环" class="heading-link"><i class="fas fa-link"></i></a>for循环</h2>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>根据数组长度，循环数组索引值，按索引值取出数组元素<br><img src="/2020/05/31/js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/1.png" alt="在这里插入图片描述"></p></li><li>        <h2 id="arr-forEach-循环">          <a href="#arr-forEach-循环" class="heading-link"><i class="fas fa-link"></i></a>arr.forEach()循环</h2>      <ul><li>1.参数一(必须)：回调函数，该回调函数有三个参数(currentValue:当前元素, index:当前元素索引值, arr:当前数组对象）</li><li>2.参数二(可选)：指定this的指向。<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value,index,array)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure><img src="/2020/05/31/js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/2.png" alt="在这里插入图片描述"></li></ul></li><li>        <h2 id="for-of-与-for-in">          <a href="#for-of-与-for-in" class="heading-link"><i class="fas fa-link"></i></a>for of 与 for in</h2>      <ul><li>1.for of——- 直接循环遍历出数组的值</li><li>2.for in——-循环遍历出索引值，需要根据索引值去数组取出值</li></ul></li></ul><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(item) <span class="comment">// 你 我 他 你</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])<span class="comment">// 你 我 他 你</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>        <h2 id="arr-indexOf-与-arr-lastIndexOf">          <a href="#arr-indexOf-与-arr-lastIndexOf" class="heading-link"><i class="fas fa-link"></i></a>arr.indexOf 与 arr.lastIndexOf</h2>      <ul><li>1.arr.indexOf——- 数组从左往右遍历，如果找到匹配的值，停止寻找，返回该元素的索引值，找不到返回-1</li><li>2.arr.lastIndexOf——-从右往左遍历,其他和indexOf相同<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'你'</span>)) <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'你'</span>))<span class="comment">//3</span></span><br></pre></td></tr></table></div></figure></li></ul></li><li>        <h2 id="arr-some">          <a href="#arr-some" class="heading-link"><i class="fas fa-link"></i></a>arr.some()</h2>      <p>循环遍历数组，查找数组中的元素，是否满足某一要求，只要有一个满足，返回true</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> result = arr.some(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="string">'你'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result)<span class="comment">// true</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="arr-every">          <a href="#arr-every" class="heading-link"><i class="fas fa-link"></i></a>arr.every()</h2>      <p>循环遍历数组，数组中的所有元素，满足条件时，才返回true</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result2 = arr.every(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="string">'你'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result2)<span class="comment">// false</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="arr-map">          <a href="#arr-map" class="heading-link"><i class="fas fa-link"></i></a>arr.map()</h2>      <p>对数组元素进行操作，return的值作为对应位置的元素值，返回一个新数组</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = arr.map(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value +<span class="string">'-----'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)<span class="comment">// [ '你-----', '我-----', '他-----', '你-----' ]</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="arr-filter">          <a href="#arr-filter" class="heading-link"><i class="fas fa-link"></i></a>arr.filter()</h2>      <p>过滤数组，保留返回true，不保留返回false</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="keyword">const</span> newArr2 = arr.filter(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list.indexOf(value) === <span class="number">-1</span>) &#123;</span><br><span class="line">    list.push(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr2)<span class="comment">// [ '你', '我', '他' ]</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="arr-reduce">          <a href="#arr-reduce" class="heading-link"><i class="fas fa-link"></i></a>arr.reduce()</h2>      <ul><li>1.参数一：回调函数，参数组成（previousValue：初值或return 的值, currentValue：当前元素的值, currentIndex:当前元素的索引值, array：遍历的数组对象）</li><li>2.参数二：可选，第一次循环时previousValue的值<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr3 = arr.reduce(<span class="function">(<span class="params">previousValue, currentValue, currentIndex, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue</span><br><span class="line">&#125;,<span class="string">'初值'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newArr3)<span class="comment">//初值你我他你</span></span><br></pre></td></tr></table></div></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/05/31/js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/banner.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="summary" scheme="http://yoursite.com/tags/summary/"/>
    
  </entry>
  
  <entry>
    <title>学习之js赋值、深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-05-27T14:55:45.000Z</published>
    <updated>2020-06-20T12:17:27.368Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/banner.png" alt></p><a id="more"></a>           <h2 id="使用场景">          <a href="#使用场景" class="heading-link"><i class="fas fa-link"></i></a>使用场景</h2>      <pre><code>当你想使用并修改某个数据对象，但不想对原始数据对象，进行修改时，就会用到深拷贝与浅拷贝了</code></pre>        <h2 id="数据类型">          <a href="#数据类型" class="heading-link"><i class="fas fa-link"></i></a>数据类型</h2>      <p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt></p><ul><li>1.基本数据类型<br>String，Boolean，Number，Null，Undefined，Symbol(es6)，存放在栈中，对数据进行直接访问</li><li>2.引用数据类型<br>Object(Array，Date，Function)，引用地址存放在栈中，数据存放在堆中，需要先在栈中获取引用地址，再从堆内存中获取数据</li></ul>        <h2 id="堆和栈—数据存储的结构">          <a href="#堆和栈—数据存储的结构" class="heading-link"><i class="fas fa-link"></i></a>堆和栈—数据存储的结构</h2>      <p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E5%A0%86%E6%A0%88.png" alt></p><ul><li>1.栈(stack)：根据不同的数据类型，自动分配存储的内存空间，自动释放，——用于存放基本数据类型变量和对象的引用地址</li><li>堆(heap)：动态分配的内存，大小不确定，不会自动释放，程序员可以分配释放堆内存，不然只有当一个对象没有任何变量引用它时，系统的垃圾回收机制才会在核实的时候回收它，—–存放对象类型的数据</li></ul>        <h2 id="赋值">          <a href="#赋值" class="heading-link"><i class="fas fa-link"></i></a>赋值</h2>      <p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E8%B5%8B%E5%80%BC.png" alt><br>将某一数值或对象赋给某个变量的过程</p><ul><li>1.基本数据类型赋值<br>let a= 20，let b=a，传的是值，b===20/ true<br>改变a的值不会改变b的值</li><li>2.引用数类型赋值<br>let obj={a:’zzz’},let obj2=obj1，给obj2变量的得到的是一个地址，这个地址指向的是堆内存的数据<br>obj与obj2的地址是同一个，改变其中任何一个的值，另一方都会发生变化</li></ul>        <h2 id="浅拷贝-Shallow-Copy-与深拷贝-Deep-Copy">          <a href="#浅拷贝-Shallow-Copy-与深拷贝-Deep-Copy" class="heading-link"><i class="fas fa-link"></i></a>浅拷贝(Shallow Copy)与深拷贝(Deep Copy)</h2>      <p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt></p><ul><li>1.浅拷贝：只复制一层对象的属性(基本数据类型)，并不包括对象里面的为引用类型的数据，es6中，Object.assign()方法，实行的就是浅拷贝</li><li>2.深拷贝：复制多层，对对象以及对象的所有子对象进行拷贝<br>⚠️：赋值得到的是原来对象的地址，而浅拷贝与深拷贝，都是得到一个新的对象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/banner.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习之js执行机制</title>
    <link href="http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-27T14:54:55.000Z</published>
    <updated>2020-06-20T12:17:27.372Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/banner.png" alt></p><a id="more"></a><p>javascript是一门单线程语言，一件事情做完后，再做另一件事情。上一件事情没做完，就必须等着，不能同时干。</p>        <h2 id="为什么js是单线程的呢？">          <a href="#为什么js是单线程的呢？" class="heading-link"><i class="fas fa-link"></i></a>为什么js是单线程的呢？</h2>      <p>他的用途决定了他是单线程。若js有两个线程，一个线程删除dom节点，另一个线程为这个dom节点添加内容，此时就不知道以哪个线程为准了，很混乱。<br>但是，如果有一件事情，处理的时间很长，造成了阻塞，用户体验不好，该怎么办？—–js产生了同步和异步任务</p>        <h2 id="同步和异步任务">          <a href="#同步和异步任务" class="heading-link"><i class="fas fa-link"></i></a>同步和异步任务</h2>      <p>js执行时</p><ul><li>遇到同步任务放进主线程中执行  </li><li>遇到异步任务时，<ul><li>如果任务属于宏任务，先被放入宏任务event table中注册回调函数,指定的事件完成时,进入宏任务队列(event queue)<br>🌰例：宏任务setTimeout(function(){},3000)，等待3秒之后再执行这个函数，这个3秒就是在event table里面等的，3秒之后，再进入宏任务队列</li><li>属于微任务，先被放入微任务event table中注册回调函数，指定的事件完成时,进入微任务队列(event queue)</li></ul></li></ul>        <h2 id="怎么实现异步？">          <a href="#怎么实现异步？" class="heading-link"><i class="fas fa-link"></i></a>怎么实现异步？</h2>      <p>js通过事件循环(event loop)来实现异步</p><ul><li>同步任务：在主线程上排队，放入执行栈中执行</li><li>异步任务： 主线程执行完后，通过事件循环(event loop)，从任务队列中读取事件，进入主线程执行（⚠️先执行所以微任务，再执行宏任务）</li></ul>        <h2 id="事件循环-event-loop-是javascript的执行机制">          <a href="#事件循环-event-loop-是javascript的执行机制" class="heading-link"><i class="fas fa-link"></i></a>事件循环(event loop)是javascript的执行机制</h2>      <ul><li>1.执行栈：函数的执行就是通过进栈和出栈实现的，执行时进栈，执行完后出栈</li><li>2.主线程不断的从”任务队列”中读取事件，放入执行栈中执行<br>例：监听栈中情况，如果执行栈中为空时，主线程就会从任务队列中，读取事件,进入主线程执行栈中执行(⚠️任务队列分为两种，宏任务(macro-task)微任务(micro-task))</li></ul>        <h2 id="微任务和宏任务">          <a href="#微任务和宏任务" class="heading-link"><i class="fas fa-link"></i></a>微任务和宏任务</h2>      <ul><li>宏任务(macro-task)：包括整体代码script，setTimeout，setInterval</li><li>微任务(micro-task)： Promise，process.nextTick</li></ul><p>javacsript执行时，整体代码script作为第一个宏任务进入主线程，遇到异步任务时，如果任务属于宏任务就进入宏任务队列，属于微任务就进入微任务队列</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/banner.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习之浏览器缓存</title>
    <link href="http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</id>
    <published>2020-05-27T14:44:33.000Z</published>
    <updated>2020-06-20T12:17:27.377Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/banner.png" alt></p><a id="more"></a><p>首先，我想写写我为什么要写博客<br>第一就是想记录自己的学习过程，能够让自己在忘记这一部分的时候，能够翻出来看看，就相当于笔记一样，总结也会使我的脑子清楚<br>第二就是发泄我的表达欲，哈哈哈哈哈，有时候发现自己表达欲挺强的，闲话比较多😂不说了，开始吧</p>        <h2 id="1-浏览器发起请求的过程">          <a href="#1-浏览器发起请求的过程" class="heading-link"><i class="fas fa-link"></i></a>1.浏览器发起请求的过程</h2>      <p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82.png" alt><br>浏览器发起请求时，会先在浏览器缓存中查找该请求的结果以及缓存标志</p>        <h4 id="如果没有缓存标志，会进行下面过程">          <a href="#如果没有缓存标志，会进行下面过程" class="heading-link"><i class="fas fa-link"></i></a>如果没有缓存标志，会进行下面过程</h4>      <p> 1.向服务器发送HTTP请求<br>2.服务器返回该请求的结果和缓存规则<br>3.将该请求结果和缓存标志存入浏览器缓存中</p>        <h4 id="如果有缓存标志，会查看浏览器缓存策略，判断强缓存是否生效">          <a href="#如果有缓存标志，会查看浏览器缓存策略，判断强缓存是否生效" class="heading-link"><i class="fas fa-link"></i></a>如果有缓存标志，会查看浏览器缓存策略，判断强缓存是否生效</h4>      <p>1.如果生效，不会向服务器发送请求，直接从缓存中读取资源，根据缓存优先级，确定使用哪一种缓存<br>2.如果不生效，则要进行协商缓存  </p><ul><li>1.浏览器会携带缓存标志向服务器发送请求，由服务器决定是否使用缓存</li><li>2.如果该资源无更新，协商缓存生效，会返回状态码304和not modified，从缓存中读取资源</li><li>3.如果该资源更新了，协商缓存失败，会返回状态码200和请求结果，将请求结果和缓存标志存在浏览器缓存中</li></ul>        <h2 id="2-浏览器缓存策略">          <a href="#2-浏览器缓存策略" class="heading-link"><i class="fas fa-link"></i></a>2.浏览器缓存策略</h2>      <p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png" alt></p>        <h4 id="强缓存-包括Expires和Cache-Control">          <a href="#强缓存-包括Expires和Cache-Control" class="heading-link"><i class="fas fa-link"></i></a>强缓存-包括Expires和Cache-Control</h4>      <p>1.Expires(到期时间)，来指定资源到期时间，根据服务器的时间<br>2.Cache-Control(缓存控制)，优先级高于expires，常见值如下</p><ul><li>max-age=30，缓存三十秒后就过期，需要重新请求</li><li>no-store，不缓存任何响应</li><li>no-cache，资源被缓存，但立即失效。下次会发起请求验证资源是否过期</li></ul>        <h4 id="协商缓存-包括Last-Modified和ETag">          <a href="#协商缓存-包括Last-Modified和ETag" class="heading-link"><i class="fas fa-link"></i></a>协商缓存-包括Last-Modified和ETag</h4>      <p>1.Last-Modified</p><ul><li>浏览器第一次访问资源时，服务器会在response header中添加 Last-Modified的header–表示这个资源在服务器上最后修改的时间</li><li>浏览器下一次请求时，浏览器检测到有Last-Modified的这个header，于是在请求头上加上If-Modified-Since</li><li>这个值会与服务器上这个资源的最后修改时间进行比较<ul><li>1.若小于服务器的更新时间，说明文件有更新，于是返回新的资源文件和200</li><li>2.若等于与服务器的更新时间，说明文件没有更新，返回304和空的响应体</li></ul></li></ul><p>2.ETag，优先级高于Last-Modified</p><ul><li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成</li><li>浏览器下一次请求时，浏览器检测到有Etag，于是在请求头上加上If-None-Match里</li><li>服务器会将If-None-Match的值与自己的Etag值进行比较<ul><li>1.若值一样是返回新的资源文件和200</li><li>2.若值不一样，说明文件没有更新，返回304和空的响应体</li></ul></li></ul>        <h2 id="3-缓存位置">          <a href="#3-缓存位置" class="heading-link"><i class="fas fa-link"></i></a>3.缓存位置</h2>      <p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE.png" alt><br>1.Memory Cache(内存中的缓存)</p><ul><li>特点：读取速度快，存储空间小，一旦关闭了tab页面，内存中的缓存也就被释放了</li></ul><p>2.Disk Cache(硬盘中的缓存)</p><ul><li>特点：读取速度慢点，但存储空间大</li></ul><p>图片上还有两种，我不太理解，就不写了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/banner.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习之浏览器的渲染机制</title>
    <link href="http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-27T14:41:36.000Z</published>
    <updated>2020-06-20T12:17:27.386Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/banner.png" alt><br>当你在浏览器中输入url之后，如果请求成功，会得到服务器提供的资源（HTML，CSS，JS，图片等），浏览器会执行下面的操作</p><a id="more"></a>        <h2 id="浏览器渲染操作">          <a href="#浏览器渲染操作" class="heading-link"><i class="fas fa-link"></i></a>浏览器渲染操作</h2>              <h3 id="1-解析html，得到dom树">          <a href="#1-解析html，得到dom树" class="heading-link"><i class="fas fa-link"></i></a>1.解析html，得到dom树.</h3>      <p>解析html时，是从上至下的  </p><ul><li>如果遇到link和style，那就就会去下载这些外部的css资源，但是css跟DOM的构建是并行的，不会阻塞DOM树的构建</li><li>如果遇到script，DOM树和CSSOM树的构建都会暂停，被阻塞，直到脚本加载完毕或者是执行完毕</li><li>display:none的元素也会在DOM树中</li><li>注释也会在DOM树中</li><li>所以一般样式文件应当在head标签中，而脚本文件在body结束前，这样可以防止阻塞 </li></ul>        <h3 id="2-解析css，得到层叠样式表模型cssom树-CSS-Object-Model">          <a href="#2-解析css，得到层叠样式表模型cssom树-CSS-Object-Model" class="heading-link"><i class="fas fa-link"></i></a>2.解析css，得到层叠样式表模型cssom树(CSS Object Model).</h3>      <ul><li>查找样式表是按照从右到左的顺序去匹配的</li><li>例如div p {font-size: 10px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染</li></ul>        <h3 id="3-整合dom树和cssom树，得到渲染树-render树">          <a href="#3-整合dom树和cssom树，得到渲染树-render树" class="heading-link"><i class="fas fa-link"></i></a>3.整合dom树和cssom树，得到渲染树-render树</h3>      <ul><li>display: none的元素不在Render Tree中</li><li>visibility: hidden的元素在Render Tree中  </li></ul>        <h3 id="4-布局，根据render树计算每个节点的位置和样式–盒子模型阶段">          <a href="#4-布局，根据render树计算每个节点的位置和样式–盒子模型阶段" class="heading-link"><i class="fas fa-link"></i></a>4.布局，根据render树计算每个节点的位置和样式–盒子模型阶段</h3>              <h3 id="5-绘制，根据布局计算好的信息，绘制整个页面">          <a href="#5-绘制，根据布局计算好的信息，绘制整个页面" class="heading-link"><i class="fas fa-link"></i></a>5.绘制，根据布局计算好的信息，绘制整个页面</h3>              <h2 id="回流与重绘">          <a href="#回流与重绘" class="heading-link"><i class="fas fa-link"></i></a>回流与重绘</h2>      <p>页面在浏览器中展示后，我们会执行很多dom操作，就会修改DOM或CSSOM，这时候就存在回流与重绘了，记住回流一定会重绘  </p>        <h3 id="1-回流-reflow">          <a href="#1-回流-reflow" class="heading-link"><i class="fas fa-link"></i></a>1.回流(reflow)</h3>      <ul><li>比如用户点击，展示某个图片-增加了dom节点等元素位置尺寸信息改变  </li><li>就会倒回去重新渲染，重新执行布局，重新计算节点的位置大小等信息，</li></ul>        <h3 id="1-重绘-repaint">          <a href="#1-重绘-repaint" class="heading-link"><i class="fas fa-link"></i></a>1.重绘(repaint)</h3>      <ul><li>改变背景颜色，文字颜色、边框颜色等没有改变元素形状的操作  </li><li>会重新执行绘制，绘制整个页面  </li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/banner.png&quot; alt&gt;&lt;br&gt;当你在浏览器中输入url之后，如果请求成功，会得到服务器提供的资源（HTML，CSS，JS，图片等），浏览器会执行下面的操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>vue+elementUI实战之网易云音乐总结！！！</title>
    <link href="http://yoursite.com/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/</id>
    <published>2020-05-27T04:33:17.000Z</published>
    <updated>2020-06-20T12:09:24.463Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="模仿网易云音乐pc端">          <a href="#模仿网易云音乐pc端" class="heading-link"><i class="fas fa-link"></i></a>模仿网易云音乐pc端</h1>      <p>先写写心得体会吧，经过半个月，我实现了网易云音乐的一些功能。最开始的时候，我记得我几乎写点东西，就会去看我学vue的笔记，（笔记真的好有用，什么忘记了，就拿出来看看，不懂的再百度）。我觉得这半个月最难的就是，音乐播放部分了，终于昨天晚上，我成功的实现了音乐自动播放下一首，点击按钮切换上一首，下一首，我真的好开心，哈哈哈哈哈哈。不过，项目中出现过很多问题，我要一点点的总结下来，<span class="exturl"><a class="exturl__link" href="https://github.com/xhysah/xhymusic" target="_blank" rel="noopener">项目地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p><a id="more"></a>        <h2 id="项目搭建">          <a href="#项目搭建" class="heading-link"><i class="fas fa-link"></i></a>项目搭建</h2>      <ul><li>        <h3 id="基本项目">          <a href="#基本项目" class="heading-link"><i class="fas fa-link"></i></a>基本项目</h3>      <p>   <strong>安装脚手架</strong>：npm install -g  @vue/cli</p><pre><code>**创建一个新项目**： vue create my-project(自己想取的项目名称)</code></pre><p>   1.Please pick a preset？(选择手动的，可以自己想要的配置)——-manully<br>   2.Check the features needed for your project(询问项目需求)：我选择的如下图<br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E9%A1%B9%E7%9B%AE.png" alt></p><ol start="2"><li>Use history mode for router(路由模式是否使用history)? ——-yes  </li><li>Pick a CSS pre-processor(询问项目的css预处理器)：——–Stylus   </li><li>Pick a linter / formatter config(询问项目的格式校验方式)：——Standard  </li><li>Pick additional lint features:(询问项目是什么时候校验格式)——lint on save(保存时就校验，哈哈哈哈，因为我不知道怎么写代码是规范的，需要他实时约束我)  </li><li>Where do you prefer placing config for Babel, ESLint, etc.?（询问项目的配置文件放在那里）—–In dedicated config files  </li><li>Save this as a preset for future projects? (是否保存该配置，若是，你以后创建新项目的时候，就会看见这个配置)—-no<br>然后vue-cli就开始自己下载了，等待他<br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE.png" alt><ul><li>        <h3 id="引入项目中使用的东西——axios，element-Ul">          <a href="#引入项目中使用的东西——axios，element-Ul" class="heading-link"><i class="fas fa-link"></i></a>引入项目中使用的东西——axios，element-Ul</h3>      </li></ul><strong>1.axios</strong><br>下载npm install axios –save，运行时也会使用，所有要保存在你的运行时依赖中<br>在src/main.js中：导入import axios from ‘axios’，<br>挂载到vue原型上Vue.prototype.$http = axios—-使用的时候，就可以this.$http<br>全局配置axios.defaults.baseURL = ‘<span class="exturl"><a class="exturl__link" href="http://192.168.1.5:3000&#39;">http://192.168.1.5:3000&#39;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>axios.defaults.withCredentials = true 表示跨域请求时是否需要使用凭证<br><strong>2.element-UI</strong><br>下载npm i element-ui -save<br>我是在src下面建了一个elementUI文件夹，再建了一个element.js文件<br>在这个文件中，按需引入elementUI<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#123;</span><br><span class="line">  Form,</span><br><span class="line">FormItem</span><br><span class="line"> &#125;from &#39;element-ui&#39;;</span><br><span class="line"> Vue.use(Form)</span><br><span class="line"> Vue.use(FormItem)</span><br></pre></td></tr></table></div></figure>再在main.js中引入import ‘./elementUi/element’<br>最后删掉views，components里面原本存在的vue文件，连同src/router/index.js里的路由一起删掉—-然后做完这些，我就开始研究文档了，一开始真的好难上手<br><span class="exturl"><a class="exturl__link" href="https://github.com/Binaryify/NeteaseCloudMusicApi" target="_blank" rel="noopener">网易云github地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.<br>下载后 node app.js 就可以了        <h2 id="遇到的问题">          <a href="#遇到的问题" class="heading-link"><i class="fas fa-link"></i></a>遇到的问题</h2>      <ul><li>        <h3 id="播放音乐">          <a href="#播放音乐" class="heading-link"><i class="fas fa-link"></i></a>播放音乐</h3>      最开始的时候，我知道肯定会用audio标签，建立了一个musicPlayer组件，然后把它固定在浏览器底部，因为有好几个页面都有音乐播放，所以我只能把音乐数据放在vuex里面统一管理，传给vuex的值都是可用数据了，每次只能播放一首歌，播放完后，就直接停止了，我应该在他的ended事件里面做些什么。逻辑是这样的<br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt><br>大概吧，我真的不知道怎么表述了，反正数据，我都存在vuex里面了，<br>总结：</li></ul></li></ol></li><li><p>1.在actions里面可以调用mutation——–context.commit(‘事件类型’,’参数’)，网络请求等异步操作，放在actions里面————组件调用this.$store.dispatch(‘事件类型’, ‘参数’)</p></li><li><p>2.mutations——组件调用this$store.commit(‘事件类型’,’参数’)–vuex的store状态的更新唯一方式，注意不能在actions里直接修改state里的值，改是可以改的，不提倡，容易出问题</p></li><li>        <h3 id="路由跳转">          <a href="#路由跳转" class="heading-link"><i class="fas fa-link"></i></a>路由跳转</h3>      <p>问题：elementui中的导航菜单，自带的:default-active=”activeIndex”，他只有点击才有对应的效果，你要是选择了第二项，然后刷新，他就会自动跳到第一个上面，整个导航菜单就会乱掉</p></li><li><p>我把首页里的activeName值保存在vuex中，同时也从vuex中取值，每次跳转时，都会在生命周期created里面提交修改activeName的值，路由就不会乱掉了</p></li><li>        <h3 id="flex布局">          <a href="#flex布局" class="heading-link"><i class="fas fa-link"></i></a>flex布局</h3>      <p>在项目中，我经常遇到布局问题，因为好多图片，都要居中对齐，看起来整洁一点，总结一下经常用的</p></li><li><p>容器的justify-content属性，属性值space-between两端项目之间的距离都相等，center居中对齐</p></li><li><p>容器的flex-warp—-定义一行排不下item，如何换行—-wrap换行</p></li><li><p>容器属性<br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7.png" alt></p><ul><li><p>项目属性<br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7.png" alt></p></li><li>        <h3 id="定位">          <a href="#定位" class="heading-link"><i class="fas fa-link"></i></a>定位</h3>      <p>relative：相对定位，不脱离文档流，参考自身的静态位置<br>absolute：绝对定位，参考最近一个不为static的父级元素的位置<br>fixed：固定定位，参照对象为可视窗口<br>static ：默认，按照正常流进行排列</p></li><li>        <h3 id="修饰符sync">          <a href="#修饰符sync" class="heading-link"><i class="fas fa-link"></i></a>修饰符sync</h3>      <p>在我使用elementUI时，我发现经常有数据，会加上这个修饰符.sync,一直不明白是什么意思</p></li><li><p>其实sync是一个语法糖，是什么语法糖呢？</p></li><li><p>在子组件中不能修改父组件中的值，要想修改父组件中的值，必须向父组件发射一个方法this.$emit(‘方法名’,‘修改的的值);，然后父组件接收这个方法@方法名=‘处理数据操作’</p></li><li><p>如果使用.sync,就不用上面操作了，在子组件中修改的值，父组件也会同步变化</p></li><li>        <h3 id="sessionStorage">          <a href="#sessionStorage" class="heading-link"><i class="fas fa-link"></i></a>sessionStorage</h3>      <p>存储的数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁.只能存储字符串类型,如果存储的数据类型不是字符串类型，存储时，会自动调用toString方法,存入一个对象数据，会变成 [object Object]字符串<br>数据存储不正确，获取的sessionStorage数据也就不对了</p></li><li><p>1.存储时：JSON.stringify()方法转换成字符串，再存储到sessionStorage中</p></li><li><p>2.使用时：通过JSON.parse()方法将字符串转换成JSON格式即可</p></li><li>        <h3 id="使单行文字超过一定长度显示…">          <a href="#使单行文字超过一定长度显示…" class="heading-link"><i class="fas fa-link"></i></a>使单行文字超过一定长度显示…</h3>      </li><li><p>1.规定元素的宽度  </p><pre><code>width: 200px;</code></pre></li><li><p>2.定义超过元素宽度的文字隐藏  </p><pre><code>overflow: hidden</code></pre></li><li><p>3.规定当文本溢出时包含元素时发生的事情——ellipsis(显示省略符号来代表被修剪的文本)  </p><pre><code>text-overflow: ellipsis</code></pre></li><li><p>4.规定元素不换行  </p><pre><code>white-space: nowrap  </code></pre></li><li>        <h3 id="多行文字显示…">          <a href="#多行文字显示…" class="heading-link"><i class="fas fa-link"></i></a>多行文字显示…</h3>      </li><li><p>1.规定元素的宽度  </p><pre><code>width: 200px;</code></pre></li><li><p>2.定义超过元素宽度的文字隐藏  </p><pre><code>overflow: hidden</code></pre></li><li><p>3.设置盒子样式<br>   display: -webkit-box    </p></li><li><p>4.设置盒子参考方式  </p><pre><code>-webkit-box-orient: vertical</code></pre></li><li><p>5.设置超出多少行显示省略号    </p><pre><code>-webkit-line-clamp 2</code></pre>        <h2 id="项目截图">          <a href="#项目截图" class="heading-link"><i class="fas fa-link"></i></a>项目截图</h2>      <p><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E9%A6%96%E9%A1%B5.png" alt><br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%8E%92%E8%A1%8C%E6%A6%9C.png" alt><br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%AD%8C%E5%8D%95.png" alt><br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%AD%8C%E5%8D%95%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt><br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E7%B2%BE%E5%93%81%E6%AD%8C%E5%8D%95.png" alt><br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%AD%8C%E6%89%8B.png" alt><br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%AD%8C%E6%89%8B%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt><br><img src="/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%9C%80%E6%96%B0%E9%9F%B3%E4%B9%90.png" alt></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模仿网易云音乐pc端&quot;&gt;
          &lt;a href=&quot;#模仿网易云音乐pc端&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;模仿网易云音乐pc端&lt;/h1&gt;
      &lt;p&gt;先写写心得体会吧，经过半个月，我实现了网易云音乐的一些功能。最开始的时候，我记得我几乎写点东西，就会去看我学vue的笔记，（笔记真的好有用，什么忘记了，就拿出来看看，不懂的再百度）。我觉得这半个月最难的就是，音乐播放部分了，终于昨天晚上，我成功的实现了音乐自动播放下一首，点击按钮切换上一首，下一首，我真的好开心，哈哈哈哈哈哈。不过，项目中出现过很多问题，我要一点点的总结下来，&lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot; href=&quot;https://github.com/xhysah/xhymusic&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
</feed>
