<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xhy&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-31T04:50:05.365Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xhy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>js循环数组的方法</title>
    <link href="http://yoursite.com/2020/05/31/js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/31/js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-31T04:44:41.000Z</published>
    <updated>2020-05-31T04:50:05.365Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="学习总结之js循环数组的方法"   >          <a href="#学习总结之js循环数组的方法" class="heading-link"><i class="fas fa-link"></i></a>学习总结之js循环数组的方法</h1>      <a id="more"></a><p>先声明一个数组</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="string">'你'</span>,<span class="string">'我'</span>,<span class="string">'他'</span>,<span class="string">'你'</span>]</span><br></pre></td></tr></table></div></figure><ul><li>        <h2 id="for循环"   >          <a href="#for循环" class="heading-link"><i class="fas fa-link"></i></a>for循环</h2>      <figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><p>根据数组长度，循环数组索引值，按索引值取出数组元素<br><img src="js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/1.png" alt="在这里插入图片描述"></p><ul><li>        <h2 id="arr-forEach-循环"   >          <a href="#arr-forEach-循环" class="heading-link"><i class="fas fa-link"></i></a>arr.forEach()循环</h2>      <ul><li><p>1.参数一(必须)：回调函数，该回调函数有三个参数(currentValue:当前元素, index:当前元素索引值, arr:当前数组对象）</p></li><li><p>2.参数二(可选)：指定this的指向。</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value, index, array</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value,index,array)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure><p><img src="js%E5%BE%AA%E7%8E%AF%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95/2.png" alt="在这里插入图片描述"></p></li><li>        <h2 id="for-of-与-for-in"   >          <a href="#for-of-与-for-in" class="heading-link"><i class="fas fa-link"></i></a>for of 与 for in</h2>      <ul><li>1.for of——- 直接循环遍历出数组的值</li><li>2.for in——-循环遍历出索引值，需要根据索引值去数组取出值</li></ul></li></ul></li></ul></li></ul><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(item) <span class="comment">// 你 我 他 你</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i) <span class="comment">// 0 1 2 3</span></span><br><span class="line">  <span class="built_in">console</span>.log(arr[i])<span class="comment">// 你 我 他 你</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure><ul><li>        <h2 id="arr-indexOf-与-arr-lastIndexOf"   >          <a href="#arr-indexOf-与-arr-lastIndexOf" class="heading-link"><i class="fas fa-link"></i></a>arr.indexOf 与 arr.lastIndexOf</h2>      <ul><li>1.arr.indexOf——- 数组从左往右遍历，如果找到匹配的值，停止寻找，返回该元素的索引值，找不到返回-1</li><li>2.arr.lastIndexOf——-从右往左遍历,其他和indexOf相同<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.indexOf(<span class="string">'你'</span>)) <span class="comment">//0</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.lastIndexOf(<span class="string">'你'</span>))<span class="comment">//3</span></span><br></pre></td></tr></table></div></figure></li></ul></li><li>        <h2 id="arr-some"   >          <a href="#arr-some" class="heading-link"><i class="fas fa-link"></i></a>arr.some()</h2>      <p>循环遍历数组，查找数组中的元素，是否满足某一要求，只要有一个满足，返回true</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> result = arr.some(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="string">'你'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result)<span class="comment">// true</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="arr-every"   >          <a href="#arr-every" class="heading-link"><i class="fas fa-link"></i></a>arr.every()</h2>      <p>循环遍历数组，数组中的所有元素，满足条件时，才返回true</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result2 = arr.every(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value === <span class="string">'你'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(result2)<span class="comment">// false</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="arr-map"   >          <a href="#arr-map" class="heading-link"><i class="fas fa-link"></i></a>arr.map()</h2>      <p>对数组元素进行操作，return的值作为对应位置的元素值，返回一个新数组</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr = arr.map(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value +<span class="string">'-----'</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr)<span class="comment">// [ '你-----', '我-----', '他-----', '你-----' ]</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="arr-filter"   >          <a href="#arr-filter" class="heading-link"><i class="fas fa-link"></i></a>arr.filter()</h2>      <p>过滤数组，保留返回true，不保留返回false</p><figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = []</span><br><span class="line"><span class="keyword">const</span> newArr2 = arr.filter(<span class="function">(<span class="params">value, index, array</span>) =&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (list.indexOf(value) === <span class="number">-1</span>) &#123;</span><br><span class="line">    list.push(value)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(newArr2)<span class="comment">// [ '你', '我', '他' ]</span></span><br></pre></td></tr></table></div></figure></li><li>        <h2 id="arr-reduce"   >          <a href="#arr-reduce" class="heading-link"><i class="fas fa-link"></i></a>arr.reduce()</h2>      <ul><li>1.参数一：回调函数，参数组成（previousValue：初值或return 的值, currentValue：当前元素的值, currentIndex:当前元素的索引值, array：遍历的数组对象）</li><li>2.参数二：可选，第一次循环时previousValue的值<figure class="highlight javascript"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newArr3 = arr.reduce(<span class="function">(<span class="params">previousValue, currentValue, currentIndex, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> previousValue + currentValue</span><br><span class="line">&#125;,<span class="string">'初值'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newArr3)<span class="comment">//初值你我他你</span></span><br></pre></td></tr></table></div></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习总结之js循环数组的方法&quot;   &gt;
          &lt;a href=&quot;#学习总结之js循环数组的方法&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;学习总结之js循环数组的方法&lt;/h1&gt;
    
    </summary>
    
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习之js赋值、深拷贝和浅拷贝</title>
    <link href="http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</id>
    <published>2020-05-27T14:55:45.000Z</published>
    <updated>2020-05-27T15:09:40.808Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="学习之js赋值、深拷贝和浅拷贝-新手小白的简单理解"   >          <a href="#学习之js赋值、深拷贝和浅拷贝-新手小白的简单理解" class="heading-link"><i class="fas fa-link"></i></a>学习之js赋值、深拷贝和浅拷贝(新手小白的简单理解)</h1>              <h2 id="使用场景"   >          <a href="#使用场景" class="heading-link"><i class="fas fa-link"></i></a>使用场景</h2>      <pre><code>当你想使用并修改某个数据对象，但不想对原始数据对象，进行修改时，就会用到深拷贝与浅拷贝了</code></pre><a id="more"></a>            <h2 id="数据类型"   >          <a href="#数据类型" class="heading-link"><i class="fas fa-link"></i></a>数据类型</h2>      <p><img src="%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt=""></p><ul><li>1.基本数据类型<br>String，Boolean，Number，Null，Undefined，Symbol(es6)，存放在栈中，对数据进行直接访问</li><li>2.引用数据类型<br>Object(Array，Date，Function)，引用地址存放在栈中，数据存放在堆中，需要先在栈中获取引用地址，再从堆内存中获取数据        <h2 id="堆和栈—数据存储的结构"   >          <a href="#堆和栈—数据存储的结构" class="heading-link"><i class="fas fa-link"></i></a>堆和栈—数据存储的结构</h2>      <img src="%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E5%A0%86%E6%A0%88.png" alt=""></li><li>1.栈(stack)：根据不同的数据类型，自动分配存储的内存空间，自动释放，——用于存放基本数据类型变量和对象的引用地址</li><li>堆(heap)：动态分配的内存，大小不确定，不会自动释放，程序员可以分配释放堆内存，不然只有当一个对象没有任何变量引用它时，系统的垃圾回收机制才会在核实的时候回收它，—–存放对象类型的数据        <h2 id="赋值"   >          <a href="#赋值" class="heading-link"><i class="fas fa-link"></i></a>赋值</h2>      <img src="%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E8%B5%8B%E5%80%BC.png" alt=""><br>将某一数值或对象赋给某个变量的过程</li><li>1.基本数据类型赋值<br>let a= 20，let b=a，传的是值，b===20/ true<br>改变a的值不会改变b的值</li><li>2.引用数类型赋值<br>let obj={a:’zzz’},let obj2=obj1，给obj2变量的得到的是一个地址，这个地址指向的是堆内存的数据<br>obj与obj2的地址是同一个，改变其中任何一个的值，另一方都会发生变化        <h2 id="浅拷贝-Shallow-Copy-与深拷贝-Deep-Copy"   >          <a href="#浅拷贝-Shallow-Copy-与深拷贝-Deep-Copy" class="heading-link"><i class="fas fa-link"></i></a>浅拷贝(Shallow Copy)与深拷贝(Deep Copy)</h2>      <img src="%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E8%B5%8B%E5%80%BC%E3%80%81%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D.png" alt=""></li><li>1.浅拷贝：只复制一层对象的属性(基本数据类型)，并不包括对象里面的为引用类型的数据，es6中，Object.assign()方法，实行的就是浅拷贝</li><li>2.深拷贝：复制多层，对对象以及对象的所有子对象进行拷贝<br>⚠️：赋值得到的是原来对象的地址，而浅拷贝与深拷贝，都是得到一个新的对象</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习之js赋值、深拷贝和浅拷贝-新手小白的简单理解&quot;   &gt;
          &lt;a href=&quot;#学习之js赋值、深拷贝和浅拷贝-新手小白的简单理解&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;学习之js赋值、深拷贝和浅拷贝(新手小白的简单理解)&lt;/h1&gt;
      
        &lt;h2 id=&quot;使用场景&quot;   &gt;
          &lt;a href=&quot;#使用场景&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;使用场景&lt;/h2&gt;
      &lt;pre&gt;&lt;code&gt;当你想使用并修改某个数据对象，但不想对原始数据对象，进行修改时，就会用到深拷贝与浅拷贝了&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习之js执行机制</title>
    <link href="http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8Bjs%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-27T14:54:55.000Z</published>
    <updated>2020-05-27T15:09:40.815Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="学习之js执行机制-新手小白的简单理解"   >          <a href="#学习之js执行机制-新手小白的简单理解" class="heading-link"><i class="fas fa-link"></i></a>学习之js执行机制(新手小白的简单理解)</h1>      <p>javascript是一门单线程语言，一件事情做完后，再做另一件事情。上一件事情没做完，就必须等着，不能同时干。</p><a id="more"></a>        <h2 id="为什么js是单线程的呢？"   >          <a href="#为什么js是单线程的呢？" class="heading-link"><i class="fas fa-link"></i></a>为什么js是单线程的呢？</h2>      <p>他的用途决定了他是单线程。若js有两个线程，一个线程删除dom节点，另一个线程为这个dom节点添加内容，此时就不知道以哪个线程为准了，很混乱。<br>但是，如果有一件事情，处理的时间很长，造成了阻塞，用户体验不好，该怎么办？—–js产生了同步和异步任务</p>        <h2 id="同步和异步任务"   >          <a href="#同步和异步任务" class="heading-link"><i class="fas fa-link"></i></a>同步和异步任务</h2>      <p>js执行时</p><ul><li>遇到同步任务放进主线程中执行  </li><li>遇到异步任务时，<ul><li>如果任务属于宏任务，先被放入宏任务event table中注册回调函数,指定的事件完成时,进入宏任务队列(event queue)<br>🌰例：宏任务setTimeout(function(){},3000)，等待3秒之后再执行这个函数，这个3秒就是在event table里面等的，3秒之后，再进入宏任务队列</li><li>属于微任务，先被放入微任务event table中注册回调函数，指定的事件完成时,进入微任务队列(event queue)        <h2 id="怎么实现异步？"   >          <a href="#怎么实现异步？" class="heading-link"><i class="fas fa-link"></i></a>怎么实现异步？</h2>      js通过事件循环(event loop)来实现异步</li></ul></li><li>同步任务：在主线程上排队，放入执行栈中执行</li><li>异步任务： 主线程执行完后，通过事件循环(event loop)，从任务队列中读取事件，进入主线程执行（⚠️先执行所以微任务，再执行宏任务）        <h2 id="事件循环-event-loop-是javascript的执行机制"   >          <a href="#事件循环-event-loop-是javascript的执行机制" class="heading-link"><i class="fas fa-link"></i></a>事件循环(event loop)是javascript的执行机制</h2>      </li><li>1.执行栈：函数的执行就是通过进栈和出栈实现的，执行时进栈，执行完后出栈</li><li>2.主线程不断的从”任务队列”中读取事件，放入执行栈中执行<br>例：监听栈中情况，如果执行栈中为空时，主线程就会从任务队列中，读取事件,进入主线程执行栈中执行(⚠️任务队列分为两种，宏任务(macro-task)微任务(micro-task))        <h2 id="微任务和宏任务"   >          <a href="#微任务和宏任务" class="heading-link"><i class="fas fa-link"></i></a>微任务和宏任务</h2>      </li><li>宏任务(macro-task)：包括整体代码script，setTimeout，setInterval</li><li>微任务(micro-task)： Promise，process.nextTick</li></ul><p>javacsript执行时，整体代码script作为第一个宏任务进入主线程，遇到异步任务时，如果任务属于宏任务就进入宏任务队列，属于微任务就进入微任务队列</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习之js执行机制-新手小白的简单理解&quot;   &gt;
          &lt;a href=&quot;#学习之js执行机制-新手小白的简单理解&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;学习之js执行机制(新手小白的简单理解)&lt;/h1&gt;
      &lt;p&gt;javascript是一门单线程语言，一件事情做完后，再做另一件事情。上一件事情没做完，就必须等着，不能同时干。&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习之浏览器缓存</title>
    <link href="http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    <id>http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</id>
    <published>2020-05-27T14:44:33.000Z</published>
    <updated>2020-05-27T15:09:40.812Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="学习之浏览器缓存-新手小白的简单理解"   >          <a href="#学习之浏览器缓存-新手小白的简单理解" class="heading-link"><i class="fas fa-link"></i></a>学习之浏览器缓存(新手小白的简单理解)</h1>      <p>首先，我想写写我为什么要写博客<br>第一就是想记录自己的学习过程，能够让自己在忘记这一部分的时候，能够翻出来看看，就相当于笔记一样，总结也会使我的脑子清楚<br>第二就是发泄我的表达欲，哈哈哈哈哈，有时候发现自己表达欲挺强的，闲话比较多😂不说了，开始吧</p><a id="more"></a>        <h2 id="1-浏览器发起请求的过程"   >          <a href="#1-浏览器发起请求的过程" class="heading-link"><i class="fas fa-link"></i></a>1.浏览器发起请求的过程</h2>      <p><img src="%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%B7%E6%B1%82.png" alt=""><br>浏览器发起请求时，会先在浏览器缓存中查找该请求的结果以及缓存标志</p>        <h4 id="如果没有缓存标志，会进行下面过程"   >          <a href="#如果没有缓存标志，会进行下面过程" class="heading-link"><i class="fas fa-link"></i></a>如果没有缓存标志，会进行下面过程</h4>      <p> 1.向服务器发送HTTP请求<br>2.服务器返回该请求的结果和缓存规则<br>3.将该请求结果和缓存标志存入浏览器缓存中</p>        <h4 id="如果有缓存标志，会查看浏览器缓存策略，判断强缓存是否生效"   >          <a href="#如果有缓存标志，会查看浏览器缓存策略，判断强缓存是否生效" class="heading-link"><i class="fas fa-link"></i></a>如果有缓存标志，会查看浏览器缓存策略，判断强缓存是否生效</h4>      <p>1.如果生效，不会向服务器发送请求，直接从缓存中读取资源，根据缓存优先级，确定使用哪一种缓存<br>2.如果不生效，则要进行协商缓存  </p><ul><li>1.浏览器会携带缓存标志向服务器发送请求，由服务器决定是否使用缓存</li><li>2.如果该资源无更新，协商缓存生效，会返回状态码304和not modified，从缓存中读取资源</li><li>3.如果该资源更新了，协商缓存失败，会返回状态码200和请求结果，将请求结果和缓存标志存在浏览器缓存中</li></ul>        <h2 id="2-浏览器缓存策略"   >          <a href="#2-浏览器缓存策略" class="heading-link"><i class="fas fa-link"></i></a>2.浏览器缓存策略</h2>      <p><img src="%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5.png" alt=""></p>        <h4 id="强缓存-包括Expires和Cache-Control"   >          <a href="#强缓存-包括Expires和Cache-Control" class="heading-link"><i class="fas fa-link"></i></a>强缓存-包括Expires和Cache-Control</h4>      <p>1.Expires(到期时间)，来指定资源到期时间，根据服务器的时间<br>2.Cache-Control(缓存控制)，优先级高于expires    ，常见值如下</p><ul><li>max-age=30，缓存三十秒后就过期，需要重新请求</li><li>no-store，不缓存任何响应</li><li>no-cache，资源被缓存，但立即失效。下次会发起请求验证资源是否过期        <h4 id="协商缓存-包括Last-Modified和ETag"   >          <a href="#协商缓存-包括Last-Modified和ETag" class="heading-link"><i class="fas fa-link"></i></a>协商缓存-包括Last-Modified和ETag</h4>      </li></ul><p>1.Last-Modified</p><ul><li>浏览器第一次访问资源时，服务器会在response header中添加 Last-Modified的header–表示这个资源在服务器上最后修改的时间</li><li>浏览器下一次请求时，浏览器检测到有Last-Modified的这个header，于是在请求头上加上If-Modified-Since</li><li>这个值会与服务器上这个资源的最后修改时间进行比较<ul><li>1.若小于服务器的更新时间，说明文件有更新，于是返回新的资源文件和200</li><li>2.若等于与服务器的更新时间，说明文件没有更新，返回304和空的响应体</li></ul></li></ul><p>2.ETag，优先级高于Last-Modified</p><ul><li>Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成</li><li>浏览器下一次请求时，浏览器检测到有Etag，于是在请求头上加上If-None-Match里</li><li>服务器会将If-None-Match的值与自己的Etag值进行比较<ul><li>1.若值一样是返回新的资源文件和200</li><li>2.若值不一样，说明文件没有更新，返回304和空的响应体        <h2 id="3-缓存位置"   >          <a href="#3-缓存位置" class="heading-link"><i class="fas fa-link"></i></a>3.缓存位置</h2>      <img src="%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/%E7%BC%93%E5%AD%98%E4%BD%8D%E7%BD%AE.png" alt=""></li></ul></li></ul><p>1.Memory Cache(内存中的缓存)</p><ul><li>特点：读取速度快，存储空间小，一旦关闭了tab页面，内存中的缓存也就被释放了</li></ul><p>2.Disk Cache(硬盘中的缓存)</p><ul><li>特点：读取速度慢点，但存储空间大</li></ul><p>图片上还有两种，我不太理解，就不写了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习之浏览器缓存-新手小白的简单理解&quot;   &gt;
          &lt;a href=&quot;#学习之浏览器缓存-新手小白的简单理解&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;学习之浏览器缓存(新手小白的简单理解)&lt;/h1&gt;
      &lt;p&gt;首先，我想写写我为什么要写博客&lt;br&gt;第一就是想记录自己的学习过程，能够让自己在忘记这一部分的时候，能够翻出来看看，就相当于笔记一样，总结也会使我的脑子清楚&lt;br&gt;第二就是发泄我的表达欲，哈哈哈哈哈，有时候发现自己表达欲挺强的，闲话比较多😂不说了，开始吧&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>学习之浏览器的渲染机制</title>
    <link href="http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/05/27/%E5%AD%A6%E4%B9%A0%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</id>
    <published>2020-05-27T14:41:36.000Z</published>
    <updated>2020-05-27T15:09:40.802Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="学习之浏览器的渲染机制-新手小白的简单理解"   >          <a href="#学习之浏览器的渲染机制-新手小白的简单理解" class="heading-link"><i class="fas fa-link"></i></a>学习之浏览器的渲染机制(新手小白的简单理解)</h1>      <p>当你在浏览器中输入url之后，如果请求成功，会得到服务器提供的资源（HTML，CSS，JS，图片等），浏览器会执行下面的操作</p><a id="more"></a>        <h2 id="浏览器渲染操作"   >          <a href="#浏览器渲染操作" class="heading-link"><i class="fas fa-link"></i></a>浏览器渲染操作</h2>              <h3 id="1-解析html，得到dom树"   >          <a href="#1-解析html，得到dom树" class="heading-link"><i class="fas fa-link"></i></a>1.解析html，得到dom树.</h3>      <p> 解析html时，是从上至下的  </p><ul><li>如果遇到link和style，那就就会去下载这些外部的css资源，但是css跟DOM的构建是并行的，不会阻塞DOM树的构建</li><li>如果遇到script，DOM树和CSSOM树的构建都会暂停，被阻塞，直到脚本加载完毕或者是执行完毕</li><li>display:none的元素也会在DOM树中</li><li>注释也会在DOM树中</li><li>所以一般样式文件应当在head标签中，而脚本文件在body结束前，这样可以防止阻塞        <h3 id="2-解析css，得到层叠样式表模型cssom树-CSS-Object-Model"   >          <a href="#2-解析css，得到层叠样式表模型cssom树-CSS-Object-Model" class="heading-link"><i class="fas fa-link"></i></a>2.解析css，得到层叠样式表模型cssom树(CSS Object Model).</h3>      <ul><li>查找样式表是按照从右到左的顺序去匹配的</li><li>例如div p {font-size: 10px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染        <h3 id="3-整合dom树和cssom树，得到渲染树-render树"   >          <a href="#3-整合dom树和cssom树，得到渲染树-render树" class="heading-link"><i class="fas fa-link"></i></a>3.整合dom树和cssom树，得到渲染树-render树</h3>      </li><li>display: none的元素不在Render Tree中</li><li>visibility: hidden的元素在Render Tree中        <h3 id="4-布局，根据render树计算每个节点的位置和样式–盒子模型阶段"   >          <a href="#4-布局，根据render树计算每个节点的位置和样式–盒子模型阶段" class="heading-link"><i class="fas fa-link"></i></a>4.布局，根据render树计算每个节点的位置和样式–盒子模型阶段</h3>              <h3 id="5-绘制，根据布局计算好的信息，绘制整个页面"   >          <a href="#5-绘制，根据布局计算好的信息，绘制整个页面" class="heading-link"><i class="fas fa-link"></i></a>5.绘制，根据布局计算好的信息，绘制整个页面</h3>              <h2 id="回流与重绘"   >          <a href="#回流与重绘" class="heading-link"><i class="fas fa-link"></i></a>回流与重绘</h2>      页面在浏览器中展示后，我们会执行很多dom操作，就会修改DOM或CSSOM，这时候就存在回流与重绘了，记住回流一定会重绘        <h3 id="1-回流-reflow"   >          <a href="#1-回流-reflow" class="heading-link"><i class="fas fa-link"></i></a>1.回流(reflow)</h3>      </li><li>比如用户点击，展示某个图片-增加了dom节点等元素位置尺寸信息改变</li><li>就会倒回去重新渲染，重新执行布局，重新计算节点的位置大小等信息，        <h3 id="1-重绘-repaint"   >          <a href="#1-重绘-repaint" class="heading-link"><i class="fas fa-link"></i></a>1.重绘(repaint)</h3>      </li><li>改变背景颜色，文字颜色、边框颜色等没有改变元素形状的操作</li><li>会重新执行绘制，绘制整个页面</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;学习之浏览器的渲染机制-新手小白的简单理解&quot;   &gt;
          &lt;a href=&quot;#学习之浏览器的渲染机制-新手小白的简单理解&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;学习之浏览器的渲染机制(新手小白的简单理解)&lt;/h1&gt;
      &lt;p&gt;当你在浏览器中输入url之后，如果请求成功，会得到服务器提供的资源（HTML，CSS，JS，图片等），浏览器会执行下面的操作&lt;/p&gt;
    
    </summary>
    
    
      <category term="learning" scheme="http://yoursite.com/categories/learning/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>vue+elementUI实战之网易云音乐总结！！！</title>
    <link href="http://yoursite.com/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/"/>
    <id>http://yoursite.com/2020/05/27/vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/</id>
    <published>2020-05-27T04:33:17.000Z</published>
    <updated>2020-05-28T07:48:12.848Z</updated>
    
    <content type="html"><![CDATA[        <h1 id="模仿网易云音乐pc端"   >          <a href="#模仿网易云音乐pc端" class="heading-link"><i class="fas fa-link"></i></a>模仿网易云音乐pc端</h1>      <p>先写写心得体会吧，经过半个月，我实现了网易云音乐的一些功能。最开始的时候，我记得我几乎写点东西，就会去看我学vue的笔记，（笔记真的好有用，什么忘记了，就拿出来看看，不懂的再百度）。我觉得这半个月最难的就是，音乐播放部分了，终于昨天晚上，我成功的实现了音乐自动播放下一首，点击按钮切换上一首，下一首，我真的好开心，哈哈哈哈哈哈。不过，项目中出现过很多问题，我要一点点的总结下来，<span class="exturl"><a class="exturl__link"   href="https://github.com/xhysah/xhymusic"  target="_blank" rel="noopener">项目地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p><a id="more"></a>        <h2 id="项目搭建"   >          <a href="#项目搭建" class="heading-link"><i class="fas fa-link"></i></a>项目搭建</h2>      <ul><li>        <h3 id="基本项目"   >          <a href="#基本项目" class="heading-link"><i class="fas fa-link"></i></a>基本项目</h3>      <p>   <strong>安装脚手架</strong>：npm install -g  @vue/cli</p><pre><code>**创建一个新项目**： vue create my-project(自己想取的项目名称)</code></pre><p>   1.Please pick a preset？(选择手动的，可以自己想要的配置)——-manully<br>   2.Check the features needed for your project(询问项目需求)：我选择的如下图<br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E9%A1%B9%E7%9B%AE.png" alt=""></p><ol start="2"><li>Use history mode for router(路由模式是否使用history)? ——-yes  </li><li>Pick a CSS pre-processor(询问项目的css预处理器)：——–Stylus   </li><li>Pick a linter / formatter config(询问项目的格式校验方式)：——Standard  </li><li>Pick additional lint features:(询问项目是什么时候校验格式)——lint on save(保存时就校验，哈哈哈哈，因为我不知道怎么写代码是规范的，需要他实时约束我)  </li><li>Where do you prefer placing config for Babel, ESLint, etc.?（询问项目的配置文件放在那里）—–In dedicated config files  </li><li>Save this as a preset for future projects? (是否保存该配置，若是，你以后创建新项目的时候，就会看见这个配置)—-no<br>然后vue-cli就开始自己下载了，等待他<br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E5%90%AF%E5%8A%A8%E9%A1%B9%E7%9B%AE.png" alt=""><ul><li>        <h3 id="引入项目中使用的东西——axios，element-Ul"   >          <a href="#引入项目中使用的东西——axios，element-Ul" class="heading-link"><i class="fas fa-link"></i></a>引入项目中使用的东西——axios，element-Ul</h3>      </li></ul><strong>1.axios</strong><br>下载npm install axios –save，运行时也会使用，所有要保存在你的运行时依赖中<br>在src/main.js中：导入import axios from ‘axios’，<br>挂载到vue原型上Vue.prototype.$http = axios—-使用的时候，就可以this.$http<br>全局配置axios.defaults.baseURL = ‘<span class="exturl"><a class="exturl__link"   href="http://192.168.1.5:3000&#39;" >http://192.168.1.5:3000&#39;</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span><br>axios.defaults.withCredentials = true 表示跨域请求时是否需要使用凭证<br><strong>2.element-UI</strong><br>下载npm i element-ui -save<br>我是在src下面建了一个elementUI文件夹，再建了一个element.js文件<br>在这个文件中，按需引入elementUI<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import Vue from &#39;vue&#39;</span><br><span class="line">import &#123;</span><br><span class="line">  Form,</span><br><span class="line">FormItem</span><br><span class="line"> &#125;from &#39;element-ui&#39;;</span><br><span class="line"> Vue.use(Form)</span><br><span class="line"> Vue.use(FormItem)</span><br></pre></td></tr></table></div></figure>再在main.js中引入import ‘./elementUi/element’<br>最后删掉views，components里面原本存在的vue文件，连同src/router/index.js里的路由一起删掉—-然后做完这些，我就开始研究文档了，一开始真的好难上手<br><span class="exturl"><a class="exturl__link"   href="https://github.com/Binaryify/NeteaseCloudMusicApi"  target="_blank" rel="noopener">网易云github地址</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.<br>下载后 node app.js 就可以了        <h2 id="遇到的问题"   >          <a href="#遇到的问题" class="heading-link"><i class="fas fa-link"></i></a>遇到的问题</h2>      <ul><li>        <h3 id="播放音乐"   >          <a href="#播放音乐" class="heading-link"><i class="fas fa-link"></i></a>播放音乐</h3>      最开始的时候，我知道肯定会用audio标签，建立了一个musicPlayer组件，然后把它固定在浏览器底部，因为有好几个页面都有音乐播放，所以我只能把音乐数据放在vuex里面统一管理，传给vuex的值都是可用数据了，每次只能播放一首歌，播放完后，就直接停止了，我应该在他的ended事件里面做些什么。逻辑是这样的<br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg" alt=""><br>大概吧，我真的不知道怎么表述了，反正数据，我都存在vuex里面了，<br>总结：</li></ul></li></ol></li><li><p>1.在actions里面可以调用mutation——–context.commit(‘事件类型’,’参数’)，网络请求等异步操作，放在actions里面————组件调用this.$store.dispatch(‘事件类型’, ‘参数’)</p></li><li><p>2.mutations——组件调用this$store.commit(‘事件类型’,’参数’)–vuex的store状态的更新唯一方式，注意不能在actions里直接修改state里的值，改是可以改的，不提倡，容易出问题</p></li><li>        <h3 id="路由跳转"   >          <a href="#路由跳转" class="heading-link"><i class="fas fa-link"></i></a>路由跳转</h3>      <p>问题：elementui中的导航菜单，自带的:default-active=”activeIndex”，他只有点击才有对应的效果，你要是选择了第二项，然后刷新，他就会自动跳到第一个上面，整个导航菜单就会乱掉</p></li><li><p>我把首页里的activeName值保存在vuex中，同时也从vuex中取值，每次跳转时，都会在生命周期created里面提交修改activeName的值，路由就不会乱掉了</p></li><li>        <h3 id="flex布局"   >          <a href="#flex布局" class="heading-link"><i class="fas fa-link"></i></a>flex布局</h3>      <p>在项目中，我经常遇到布局问题，因为好多图片，都要居中对齐，看起来整洁一点，总结一下经常用的</p></li><li><p>容器的justify-content属性，属性值space-between两端项目之间的距离都相等，center居中对齐</p></li><li><p>容器的flex-warp—-定义一行排不下item，如何换行—-wrap换行</p></li><li><p>容器属性<br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E5%AE%B9%E5%99%A8%E5%B1%9E%E6%80%A7.png" alt=""></p><ul><li><p>项目属性<br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E9%A1%B9%E7%9B%AE%E5%B1%9E%E6%80%A7.png" alt=""></p></li><li>        <h3 id="定位"   >          <a href="#定位" class="heading-link"><i class="fas fa-link"></i></a>定位</h3>      <p>relative：相对定位，不脱离文档流，参考自身的静态位置<br>absolute：绝对定位，参考最近一个不为static的父级元素的位置<br>fixed：固定定位，参照对象为可视窗口<br>static ：默认，按照正常流进行排列</p></li><li>        <h3 id="修饰符sync"   >          <a href="#修饰符sync" class="heading-link"><i class="fas fa-link"></i></a>修饰符sync</h3>      <p>在我使用elementUI时，我发现经常有数据，会加上这个修饰符.sync,一直不明白是什么意思</p></li><li><p>其实sync是一个语法糖，是什么语法糖呢？</p></li><li><p>在子组件中不能修改父组件中的值，要想修改父组件中的值，必须向父组件发射一个方法this.$emit(‘方法名’,‘修改的的值);，然后父组件接收这个方法@方法名=‘处理数据操作’</p></li><li><p>如果使用.sync,就不用上面操作了，在子组件中修改的值，父组件也会同步变化</p></li><li>        <h3 id="sessionStorage"   >          <a href="#sessionStorage" class="heading-link"><i class="fas fa-link"></i></a>sessionStorage</h3>      <p>存储的数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁.只能存储字符串类型,如果存储的数据类型不是字符串类型，存储时，会自动调用toString方法,存入一个对象数据，会变成 [object Object]字符串<br>数据存储不正确，获取的sessionStorage数据也就不对了</p></li><li><p>1.存储时：JSON.stringify()方法转换成字符串，再存储到sessionStorage中</p></li><li><p>2.使用时：通过JSON.parse()方法将字符串转换成JSON格式即可</p></li><li>        <h3 id="使单行文字超过一定长度显示…"   >          <a href="#使单行文字超过一定长度显示…" class="heading-link"><i class="fas fa-link"></i></a>使单行文字超过一定长度显示…</h3>      </li><li><p>1.规定元素的宽度  </p><pre><code>width: 200px;</code></pre></li><li><p>2.定义超过元素宽度的文字隐藏  </p><pre><code>overflow: hidden</code></pre></li><li><p>3.规定当文本溢出时包含元素时发生的事情——ellipsis(显示省略符号来代表被修剪的文本)  </p><pre><code>text-overflow: ellipsis</code></pre></li><li><p>4.规定元素不换行  </p><pre><code>white-space: nowrap  </code></pre></li><li>        <h3 id="多行文字显示…"   >          <a href="#多行文字显示…" class="heading-link"><i class="fas fa-link"></i></a>多行文字显示…</h3>      </li><li><p>1.规定元素的宽度  </p><pre><code>width: 200px;</code></pre></li><li><p>2.定义超过元素宽度的文字隐藏  </p><pre><code>overflow: hidden</code></pre></li><li><p>3.设置盒子样式<br>   display: -webkit-box    </p></li><li><p>4.设置盒子参考方式  </p><pre><code>-webkit-box-orient: vertical</code></pre></li><li><p>5.设置超出多少行显示省略号    </p><pre><code>-webkit-line-clamp 2</code></pre>        <h2 id="项目截图"   >          <a href="#项目截图" class="heading-link"><i class="fas fa-link"></i></a>项目截图</h2>      <p><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E9%A6%96%E9%A1%B5.png" alt=""><br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%88%91%E7%9A%84%E9%9F%B3%E4%B9%90.png" alt=""><br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%8E%92%E8%A1%8C%E6%A6%9C.png" alt=""><br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%AD%8C%E5%8D%95.png" alt=""><br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%AD%8C%E5%8D%95%E6%AD%8C%E6%9B%B2.png" alt=""><br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%AD%8C%E6%89%8B.png" alt=""><br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E6%AD%8C%E6%89%8B%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt=""><br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/mv%E6%92%AD%E6%94%BE.png" alt=""><br><img src="vue-elementUI%E5%AE%9E%E6%88%98%E4%B9%8B%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%80%BB%E7%BB%93%EF%BC%81%EF%BC%81%EF%BC%81/imgs/%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE.png" alt=""></p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;模仿网易云音乐pc端&quot;   &gt;
          &lt;a href=&quot;#模仿网易云音乐pc端&quot; class=&quot;heading-link&quot;&gt;&lt;i class=&quot;fas fa-link&quot;&gt;&lt;/i&gt;&lt;/a&gt;模仿网易云音乐pc端&lt;/h1&gt;
      &lt;p&gt;先写写心得体会吧，经过半个月，我实现了网易云音乐的一些功能。最开始的时候，我记得我几乎写点东西，就会去看我学vue的笔记，（笔记真的好有用，什么忘记了，就拿出来看看，不懂的再百度）。我觉得这半个月最难的就是，音乐播放部分了，终于昨天晚上，我成功的实现了音乐自动播放下一首，点击按钮切换上一首，下一首，我真的好开心，哈哈哈哈哈哈。不过，项目中出现过很多问题，我要一点点的总结下来，&lt;span class=&quot;exturl&quot;&gt;&lt;a class=&quot;exturl__link&quot;   href=&quot;https://github.com/xhysah/xhymusic&quot;  target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;&lt;span class=&quot;exturl__icon&quot;&gt;&lt;i class=&quot;fas fa-external-link-alt&quot;&gt;&lt;/i&gt;&lt;/span&gt;&lt;/span&gt;.&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
  </entry>
  
</feed>
